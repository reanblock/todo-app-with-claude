import { createContext, useContext, useState, useEffect, useCallback } from 'react'
import { startOfMonth, endOfMonth, addMonths, subMonths } from 'date-fns'
import { loadData, saveData } from '../lib/storage'
import { createChore, validateChore, RecurrenceType } from '../types/chore'
import { generateInstancesForRange } from '../lib/recurrenceEngine'
import { formatDateISO } from '../lib/dateUtils'

const ChoreContext = createContext()

export function ChoreProvider({ children }) {
  const [data, setData] = useState(() => loadData())
  const [instances, setInstances] = useState(data.instances || [])
  const [templates, setTemplates] = useState(data.templates || [])

  // Generate instances for current and adjacent months when templates change
  useEffect(() => {
    if (templates.length > 0) {
      const now = new Date()
      const startDate = formatDateISO(startOfMonth(subMonths(now, 1)))
      const endDate = formatDateISO(endOfMonth(addMonths(now, 2)))

      const newInstances = generateInstancesForRange(templates, startDate, endDate, instances)

      if (newInstances.length > 0) {
        setInstances((prev) => [...prev, ...newInstances])
      }
    }
  }, [templates])

  // Save to localStorage whenever data changes
  useEffect(() => {
    const updatedData = {
      ...data,
      instances,
      templates,
    }
    saveData(updatedData)
  }, [instances, templates, data])

  /**
   * Add a new chore (one-off or template)
   */
  const addChore = useCallback((choreData) => {
    const chore = createChore(choreData)

    // Validate
    const validation = validateChore(chore)
    if (!validation.valid) {
      throw new Error(validation.error)
    }

    // If it's a recurring chore, create as template
    if (chore.recurrence.type !== RecurrenceType.NONE) {
      const template = {
        ...chore,
        isTemplate: true,
        recurrence: {
          ...chore.recurrence,
          startDate: chore.recurrence.startDate || chore.dueDate,
        },
      }
      setTemplates((prev) => [...prev, template])
      // Note: Instances will be generated by recurrenceEngine later
    } else {
      // One-off chore
      setInstances((prev) => [...prev, chore])
    }

    return chore
  }, [])

  /**
   * Update an existing chore
   */
  const updateChore = useCallback((choreId, updates) => {
    setInstances((prev) =>
      prev.map((chore) => {
        if (chore.id === choreId) {
          return {
            ...chore,
            ...updates,
            updatedAt: new Date().toISOString(),
          }
        }
        return chore
      })
    )

    setTemplates((prev) =>
      prev.map((template) => {
        if (template.id === choreId) {
          return {
            ...template,
            ...updates,
            updatedAt: new Date().toISOString(),
          }
        }
        return template
      })
    )
  }, [])

  /**
   * Delete a chore
   */
  const deleteChore = useCallback((choreId) => {
    setInstances((prev) => prev.filter((chore) => chore.id !== choreId))
    setTemplates((prev) => prev.filter((template) => template.id !== choreId))
  }, [])

  /**
   * Delete entire recurring series (template + all instances)
   */
  const deleteRecurringSeries = useCallback((templateId) => {
    // Delete template
    setTemplates((prev) => prev.filter((template) => template.id !== templateId))

    // Delete all instances with this parentId
    setInstances((prev) =>
      prev.filter((instance) => instance.recurrence?.parentId !== templateId)
    )
  }, [])

  /**
   * Update a recurring template and regenerate future instances
   */
  const updateTemplate = useCallback((templateId, updates) => {
    setTemplates((prev) =>
      prev.map((template) => {
        if (template.id === templateId) {
          return {
            ...template,
            ...updates,
            updatedAt: new Date().toISOString(),
          }
        }
        return template
      })
    )

    // Delete all future instances (they'll be regenerated)
    const today = formatDateISO(new Date())
    setInstances((prev) =>
      prev.filter(
        (instance) =>
          instance.recurrence?.parentId !== templateId || instance.dueDate < today
      )
    )
  }, [])

  /**
   * Detach an instance from its template (for editing single occurrence)
   */
  const detachInstance = useCallback((instanceId) => {
    setInstances((prev) =>
      prev.map((instance) => {
        if (instance.id === instanceId) {
          return {
            ...instance,
            recurrence: {
              type: RecurrenceType.NONE,
              startDate: null,
              endDate: null,
              parentId: null,
            },
            updatedAt: new Date().toISOString(),
          }
        }
        return instance
      })
    )
  }, [])

  /**
   * Toggle chore completion status
   */
  const toggleComplete = useCallback((choreId) => {
    setInstances((prev) =>
      prev.map((chore) => {
        if (chore.id === choreId) {
          return {
            ...chore,
            completed: !chore.completed,
            updatedAt: new Date().toISOString(),
          }
        }
        return chore
      })
    )
  }, [])

  /**
   * Generate instances for a specific date range (e.g., when navigating months)
   */
  const generateForDateRange = useCallback((startDate, endDate) => {
    const start = formatDateISO(startDate)
    const end = formatDateISO(endDate)

    const newInstances = generateInstancesForRange(templates, start, end, instances)

    if (newInstances.length > 0) {
      setInstances((prev) => [...prev, ...newInstances])
    }
  }, [templates, instances])

  /**
   * Get all chores (instances only, not templates)
   */
  const chores = instances

  const value = {
    chores,
    templates,
    addChore,
    updateChore,
    deleteChore,
    deleteRecurringSeries,
    updateTemplate,
    detachInstance,
    toggleComplete,
    generateForDateRange,
  }

  return <ChoreContext.Provider value={value}>{children}</ChoreContext.Provider>
}

/**
 * Hook to use chore context
 */
export function useChores() {
  const context = useContext(ChoreContext)
  if (!context) {
    throw new Error('useChores must be used within ChoreProvider')
  }
  return context
}

export default ChoreContext
